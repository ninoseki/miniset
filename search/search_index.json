{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Miniset","text":"<p>A Jinja2 template processor for interacting with an SQL engine.</p> <p>(Forked from apache/superset and sripathikrishnan/jinjasql)</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install mini-set\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>First, import <code>JinjaTemplateProcessor</code> class from <code>miniset</code> and create a processor.</p> <pre><code>from miniset import JinjaTemplateProcessor\n\np = JinjaTemplateProcessor()\n</code></pre> <p>Next, call <code>prepare_query</code> method with a Jinja2 template and keyword arguments. Keyword arguments are passed to a Jinja2 context.</p> <p>The method returns:</p> <ul> <li><code>query</code> is the generated SQL query. Variables are replaced by <code>%s</code>.</li> <li><code>bind_params</code> is a list of parameters corresponding to the <code>%s</code>.</li> </ul> <pre><code>query, bind_params = p.prepare_query(\n    \"SELECT * FROM {{ table | sql_safe }} WHERE name = {{ name }} OR project_id IN {{ project_ids | where_in }}\",\n    name=\"foo\",\n    project_ids=[1, 2],\n    table=\"projects\",\n)\n</code></pre> <p>query</p> <pre><code>SELECT * FROM projects WHERE name = %s OR project_id IN (%s,%s)\n</code></pre> <p>bind_params</p> <pre><code>[\"foo\", 1, 2]\n</code></pre>"},{"location":"#multiple-param-styles","title":"Multiple Param Styles","text":"<p>A placeholder for a bind param can be specified in multiple ways.</p> <ul> <li><code>format</code>: where name = <code>%s</code>. This is the default.</li> <li><code>qmark</code>: where name = <code>?</code>.</li> <li><code>numeric</code>: where name = <code>:1</code> and last_name = <code>:2</code>.</li> <li><code>named</code>: where name = <code>:name</code> and last_name = <code>:last_name</code>.</li> <li><code>pyformat</code>: where name = <code>%(name)s</code> and last_name = <code>%(last_name)s</code>.</li> <li><code>asyncpg</code>: where name = <code>$1</code> and last_name = <code>$2</code>.</li> </ul> <p>Note</p> <p>You need to escape <code>%</code> by <code>%%</code> if you want to use <code>%</code> literal in your query with <code>format</code>. (e.g., <code>column LIKE '%%blah%%'</code>)</p> <p>Note</p> <p>See Working Along With SQLAlchemy to use this library with SQLAlchemy v2.</p> <p>You can pass the optional constructor argument <code>param_style</code> to control the style of query parameter.</p> <pre><code>p = JinjaTemplateProcessor(param_style=\"named\")\n</code></pre> <p>In case of <code>named</code> and <code>pyformat</code>, <code>prepare_query</code> returns <code>dict</code> instead of <code>list</code>.</p> <pre><code>p = JinjaTemplateProcessor(param_style=\"named\")\n\nquery, bind_params = p.prepare_query(\n    \"SELECT * FROM {{ table | sql_safe }} WHERE name = {{ name }} OR project_id IN {{ project_ids | where_in }}\",\n    name=\"foo\",\n    project_ids=[1, 2],\n    table=\"projects\",\n)\n</code></pre> <p>query</p> <pre><code>SELECT * FROM projects WHERE name = :name_1 OR project_id IN (:where_in_2,:where_in_3)\n</code></pre> <p>bind_params</p> <pre><code>{\"name_1\": \"foo\", \"where_in_2\": 1, \"where_in_3\": 2}\n</code></pre>"},{"location":"#built-in-filters","title":"Built-in Filters","text":"<p>Miniset provides the following built-in Jinja2 filters.</p>"},{"location":"#where_in","title":"where_in","text":"<p><code>where_in</code> filter builds a parenthesis list suitable for an <code>IN</code> expression.</p> <pre><code>SELECT * FROM projects WHERE project_id IN {{ project_ids | where_in }}\n</code></pre> <p>For example,</p> <pre><code>query, bind_params = p.prepare_query(\n    \"SELECT * FROM projects WHERE project_id IN {{ project_ids | where_in }}\",\n    project_ids=[1, 2, 3],\n)\n</code></pre> <p>query</p> <pre><code>SELECT * FROM projects WHERE project_id IN (%s,%s,%s)\n</code></pre> <p>bind_params</p> <pre><code>[1, 2, 3]\n</code></pre>"},{"location":"#sql_safe","title":"sql_safe","text":"<p>Table and columns names are usually not allowed in bind params.</p> <p>In such case, you can use <code>sql_safe</code> filter.</p> <pre><code>SELECT {{ column | sql_safe }} FROM {{ table | sql_safe }}\n</code></pre> <p>For example,</p> <pre><code>query, bind_params = p.prepare_query(\n    \"SELECT {{ column | sql_safe }} FROM {{ table | sql_safe }}\",\n    column=\"id\",\n    table=\"projects\",\n)\n</code></pre> <p>query</p> <pre><code>SELECT id FROM projects\n</code></pre> <p>Warning</p> <p>You have a responsibility to ensure that there is no SQL injection if you use <code>sql_safe</code> filter.</p>"},{"location":"#identifier","title":"identifier","text":"<p><code>identifier</code> filter quotes a value to make it a named object.</p> <pre><code>SELECT * from {{ table | identifier }}\n</code></pre> <p>You can use <code>identifier_quote_character</code> constructor argument to control the quote character for the identifier. (Defaults to <code>\"</code>)</p> <pre><code>p = JinjaTemplateProcessor(identifier_quote_character=\"`\")\n\nquery, bind_params = p.prepare_query(\n    \"SELECT * FROM {{ table | identifier }}\",\n    table=\"projects\",\n)\n</code></pre> <p>query</p> <pre><code>SELECT * FROM `projects`\n</code></pre>"},{"location":"#working-along-with-sqlalchemy-v2","title":"Working Along With SQLAlchemy v2","text":"<p>You cannot use <code>format</code> and <code>pyformat</code> param styles with SQLAlchemy v2 because of this change.</p> <p>Alternatively, you can use <code>named</code>, <code>qmark</code>, <code>numeric</code> and <code>asyncpg</code>.</p> <p>named</p> <pre><code>p = JinjaTemplateProcessor(param_style=\"named\")\n\nquery, bind_params = p.prepare_query(\n    \"SELECT * FROM hero WHERE id = {{ id }}\",\n    id=1,\n)\n\nwith engine.connect() as conn:\n    res = conn.execute(text(query), bind_params)\n</code></pre> <p>others (<code>qmark</code>, <code>numeric</code> and <code>asyncpg</code>)</p> <pre><code>p = JinjaTemplateProcessor(param_style=\"qmark\")\n\nquery, bind_params = p.prepare_query(\n    \"SELECT * FROM hero WHERE id = {{ id }}\",\n    id=1,\n)\n\nwith engine.connect() as conn:\n    res = conn.exec_driver_sql(query, tuple(bind_params))\n</code></pre>"},{"location":"references/exceptions/","title":"Exceptions","text":""},{"location":"references/exceptions/#miniset.exceptions","title":"<code>miniset.exceptions</code>","text":""},{"location":"references/exceptions/#miniset.exceptions.MinisetException","title":"<code>MinisetException(message='', exception=None, error_type=None)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class for Miniset</p> Source code in <code>miniset/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str = \"\",\n    exception: Optional[Exception] = None,\n    error_type: Optional[str] = None,\n) -&gt; None:\n    self.message = message\n\n    self._exception = exception\n    self._error_type = error_type\n\n    super().__init__(self.message)\n</code></pre>"},{"location":"references/exceptions/#miniset.exceptions.MinisetTemplateException","title":"<code>MinisetTemplateException(message='', exception=None, error_type=None)</code>","text":"<p>               Bases: <code>MinisetException</code></p> <p>Miniset template exception</p> Source code in <code>miniset/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str = \"\",\n    exception: Optional[Exception] = None,\n    error_type: Optional[str] = None,\n) -&gt; None:\n    self.message = message\n\n    self._exception = exception\n    self._error_type = error_type\n\n    super().__init__(self.message)\n</code></pre>"},{"location":"references/extensions/","title":"Extensions","text":""},{"location":"references/extensions/#miniset.extensions","title":"<code>miniset.extensions</code>","text":""},{"location":"references/extensions/#miniset.extensions.SqlExtension","title":"<code>SqlExtension</code>","text":"<p>               Bases: <code>Extension</code></p> <p>SQL extension for Jinja2</p>"},{"location":"references/extensions/#miniset.extensions.SqlExtension.extract_param_name","title":"<code>extract_param_name(tokens)</code>","text":"<p>Extract param names</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>list[Token]</code> <p>Tokens</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Param name</p> Source code in <code>miniset/extensions.py</code> <pre><code>def extract_param_name(self, tokens: list[Token]) -&gt; str:\n    \"\"\"Extract param names\n\n    Args:\n        tokens (list[Token]): Tokens\n\n    Returns:\n        str: Param name\n    \"\"\"\n    name: str = \"\"\n\n    for token in tokens:\n        if token.test(\"variable_begin\"):\n            continue\n\n        if token.test(\"name\") or token.test(\"dot\"):\n            name += token.value\n\n        break\n\n    if not name:\n        name = \"bind#0\"\n\n    return name\n</code></pre>"},{"location":"references/extensions/#miniset.extensions.SqlExtension.filter_stream","title":"<code>filter_stream(stream)</code>","text":"<p>Convert <code>{{ some.variable | filter1 | filter 2 }}</code> to <code>{{ ( some.variable | filter1 | filter 2 ) | bind }}</code> for all variable declarations in the template</p> <p>Note the extra ( and ). We want the | bind to apply to the entire value, not just the last value. The parentheses are mostly redundant, except in expressions like <code>{{ '%' ~ myval ~ '%' }}</code></p> <p>This function is called by Jinja2 immediately after the lexing stage, but before the parser is called.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>TokenStream</code> <p>Token stream</p> required <p>Yields:</p> Type Description <code>Token</code> <p>Generator[Token, None, None]: Converted token stream</p> Source code in <code>miniset/extensions.py</code> <pre><code>def filter_stream(self, stream: TokenStream) -&gt; Generator[Token, None, None]:\n    \"\"\"Convert `{{ some.variable | filter1 | filter 2 }}` to `{{ ( some.variable | filter1 | filter 2 ) | bind }}` for all variable declarations in the template\n\n    Note the extra ( and ). We want the | bind to apply to the entire value, not just the last value.\n    The parentheses are mostly redundant, except in expressions like `{{ '%' ~ myval ~ '%' }}`\n\n    This function is called by Jinja2 immediately after the lexing stage, but before the parser is called.\n\n    Args:\n        stream (TokenStream): Token stream\n\n    Yields:\n        Generator[Token, None, None]: Converted token stream\n    \"\"\"\n\n    while not stream.eos:\n        token = next(stream)\n        if token.test(\"variable_begin\"):\n            var_expr: list[Token] = []\n\n            while not token.test(\"variable_end\"):\n                var_expr.append(token)\n                token = next(stream)\n\n            variable_end = token\n\n            last_token = var_expr[-1]\n            lineno = last_token.lineno\n            # don't bind twice\n            if not last_token.test(\"name\") or last_token.value not in (\n                \"bind\",\n                \"where_in\",\n                \"sql_safe\",\n            ):\n                param_name = self.extract_param_name(var_expr)\n\n                var_expr.insert(1, Token(lineno, \"lparen\", \"(\"))\n                var_expr.append(Token(lineno, \"rparen\", \")\"))\n                var_expr.append(Token(lineno, \"pipe\", \"|\"))\n                var_expr.append(Token(lineno, \"name\", \"bind\"))\n                var_expr.append(Token(lineno, \"lparen\", \"(\"))\n                var_expr.append(Token(lineno, \"string\", param_name))\n                var_expr.append(Token(lineno, \"rparen\", \")\"))\n\n            var_expr.append(variable_end)\n\n            for token in var_expr:\n                yield token\n        else:\n            yield token\n</code></pre>"},{"location":"references/filters/","title":"Filters","text":""},{"location":"references/filters/#miniset.filters","title":"<code>miniset.filters</code>","text":""},{"location":"references/filters/#miniset.filters.build_identifier_filter","title":"<code>build_identifier_filter(identifier_quote_character)</code>","text":"<p>Build identifier filter based on a quote character</p> <p>Parameters:</p> Name Type Description Default <code>identifier_quote_character</code> <code>IdentifierQuoteCharacterType</code> <p>Quote character for identifier</p> required Source code in <code>miniset/filters.py</code> <pre><code>def build_identifier_filter(\n    identifier_quote_character: types.IdentifierQuoteCharacterType,\n):\n    \"\"\"Build identifier filter based on a quote character\n\n    Args:\n        identifier_quote_character (types.IdentifierQuoteCharacterType): Quote character for identifier\n    \"\"\"\n\n    def quote_and_escape(value: str):\n        # Escape double quote with 2 double quotes,\n        # or escape backtick with 2 backticks\n        return (\n            identifier_quote_character\n            + value.replace(identifier_quote_character, identifier_quote_character * 2)\n            + identifier_quote_character\n        )\n\n    def identifier_filter(raw_identifier: Union[Iterable[str], str]):\n        if isinstance(raw_identifier, str):\n            raw_identifier = (raw_identifier,)\n\n        if not isinstance(raw_identifier, Iterable):\n            raise ValueError(\"identifier filter expects a string or an Iterable\")\n\n        return Markup(\".\".join(quote_and_escape(s) for s in raw_identifier))\n\n    return identifier_filter\n</code></pre>"},{"location":"references/filters/#miniset.filters.dummy_sql_safe","title":"<code>dummy_sql_safe(value)</code>","text":"<p>Dummy sql_safe filter for linting</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Value</p> Source code in <code>miniset/filters.py</code> <pre><code>def dummy_sql_safe(value: Any) -&gt; Any:\n    \"\"\"Dummy sql_safe filter for linting\n\n    Args:\n        value (Any): Value\n\n    Returns:\n        Any: Value\n    \"\"\"\n    return value\n</code></pre>"},{"location":"references/filters/#miniset.filters.dummy_where_in","title":"<code>dummy_where_in(values, mark=\"'\")</code>","text":"<p>Dummy where_in filter for linting</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>List[Any]</code> <p>Values</p> required <code>mark</code> <code>str</code> <p>Quote mark. Defaults to \"'\".</p> <code>\"'\"</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of a parenthesis list suitable for an IN expression</p> Source code in <code>miniset/filters.py</code> <pre><code>def dummy_where_in(values: list[Any], mark: str = \"'\") -&gt; str:\n    \"\"\"Dummy where_in filter for linting\n\n    Args:\n        values (List[Any]): Values\n        mark (str, optional): Quote mark. Defaults to \"'\".\n\n    Returns:\n        str: A string representation of a parenthesis list suitable for an IN expression\n    \"\"\"\n\n    def quote(value: Any) -&gt; str:\n        if isinstance(value, str):\n            value = value.replace(mark, mark * 2)\n            return f\"{mark}{value}{mark}\"\n\n        return str(value)\n\n    joined_values = \", \".join(quote(value) for value in values)\n    return f\"({joined_values})\"\n</code></pre>"},{"location":"references/filters/#miniset.filters.sql_safe","title":"<code>sql_safe(value)</code>","text":"<p>Filter to mark the value of an expression as safe for inserting in a SQL statement</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value</p> required <p>Returns:</p> Name Type Description <code>Markup</code> <code>Markup</code> <p>Markup</p> Source code in <code>miniset/filters.py</code> <pre><code>def sql_safe(value: Any) -&gt; Markup:\n    \"\"\"Filter to mark the value of an expression as safe for inserting in a SQL statement\n\n    Args:\n        value (Any): Value\n\n    Returns:\n        Markup: Markup\n    \"\"\"\n    return Markup(value)\n</code></pre>"},{"location":"references/jinja_context/","title":"Jinja Context","text":""},{"location":"references/jinja_context/#miniset.jinja_context","title":"<code>miniset.jinja_context</code>","text":""},{"location":"references/jinja_context/#miniset.jinja_context.JinjaTemplateProcessor","title":"<code>JinjaTemplateProcessor(*, param_style='format', identifier_quote_character='\"', env=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>param_style</code> <code>ParamStyleType</code> <p>Parameter style. Defaults to \"format\".</p> <code>'format'</code> <code>identifier_quote_character</code> <code>IdentifierQuoteCharacterType</code> <p>Identifier for quote character. Defaults to '\"'.</p> <code>'\"'</code> <code>env</code> <code>Optional[Environment]</code> <p>Jinja2 environment. Defaults to None.</p> <code>None</code> Source code in <code>miniset/jinja_context.py</code> <pre><code>def __init__(\n    self,\n    *,\n    param_style: types.ParamStyleType = \"format\",\n    identifier_quote_character: types.IdentifierQuoteCharacterType = '\"',\n    env: Optional[Environment] = None,\n) -&gt; None:\n    \"\"\"Initialize the template processor.\n\n    Args:\n        param_style (types.ParamStyleType, optional): Parameter style. Defaults to \"format\".\n        identifier_quote_character (types.IdentifierQuoteCharacterType, optional): Identifier for quote character. Defaults to '\"'.\n        env (Optional[Environment], optional): Jinja2 environment. Defaults to None.\n    \"\"\"\n    self._context: dict[str, Any] = {}\n\n    self._env = env or SandboxedEnvironment(undefined=DebugUndefined)\n    self._env.autoescape = True\n    self._env.add_extension(SqlExtension)\n    self._env.filters[\"bind\"] = self._bind\n    self._env.filters[\"where_in\"] = self._where_in\n    self._env.filters[\"sql_safe\"] = sql_safe\n    self._env.filters[\"identifier\"] = build_identifier_filter(\n        identifier_quote_character\n    )\n\n    self._param_style: types.ParamStyleType = param_style\n\n    self._param_index: int = 0\n    self._bind_params: OrderedDict[str, Any] = OrderedDict()\n</code></pre>"},{"location":"references/jinja_context/#miniset.jinja_context.JinjaTemplateProcessor.prepare_query","title":"<code>prepare_query(query, **kwargs)</code>","text":"<p>Prepare a query template</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, Template]</code> <p>A query string/template</p> required <p>Returns:</p> Name Type Description <code>query</code> <code>str</code> <p>A prepared query</p> <code>bind_params</code> <code>Union[List[Any], Dict[str, Any]]</code> <p>Bind params</p> Source code in <code>miniset/jinja_context.py</code> <pre><code>def prepare_query(\n    self, query: Union[str, Template], **kwargs: Any\n) -&gt; tuple[str, Union[list[Any], dict[str, Any]]]:\n    \"\"\"Prepare a query template\n\n    Args:\n        query (Union[str, Template]): A query string/template\n\n    Returns:\n        query (str): A prepared query\n        bind_params (Union[List[Any], Dict[str, Any]]): Bind params\n    \"\"\"\n    template: Template = (\n        query if isinstance(query, Template) else self._env.from_string(query)\n    )\n    return self._prepare_query(template, **kwargs)\n</code></pre>"},{"location":"references/jinja_context/#miniset.jinja_context.JinjaTemplateProcessor.set_context","title":"<code>set_context(**kwargs)</code>","text":"<p>Set Jinja2 context</p> Source code in <code>miniset/jinja_context.py</code> <pre><code>def set_context(self, **kwargs: Any) -&gt; None:\n    \"\"\"Set Jinja2 context\"\"\"\n    self._context.update(kwargs)\n</code></pre>"},{"location":"references/types/","title":"Types","text":""},{"location":"references/types/#miniset.types.ParamStyleType","title":"<code>miniset.types.ParamStyleType = Literal['qmark', 'format', 'numeric', 'named', 'pyformat', 'asyncpg']</code>  <code>module-attribute</code>","text":""},{"location":"references/types/#miniset.types.IdentifierQuoteCharacterType","title":"<code>miniset.types.IdentifierQuoteCharacterType = Literal['`', '\"']</code>  <code>module-attribute</code>","text":""}]}